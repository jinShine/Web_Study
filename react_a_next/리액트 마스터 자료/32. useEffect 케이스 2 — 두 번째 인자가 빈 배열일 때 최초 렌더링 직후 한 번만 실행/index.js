// 32. useEffect 케이스 2 — 두 번째 인자가 빈 배열일 때: 최초 렌더링 직후 한 번만 실행
// ---------------------------------------------------------------------------------
// [핵심 요약]
// - useEffect의 두 번째 인자(의존성 배열)가 빈 배열([])이면, “최초 렌더링 직후 단 한 번만” 실행됩니다.
// - React는 내부적으로 렌더링 → DOM 커밋 후, 의존성 배열을 비교합니다.
//   빈 배열이므로 이후 렌더링에서도 다시 실행할 필요가 없다고 판단합니다.
// - Cleanup 함수(return 내부)는 컴포넌트가 “화면에서 사라질 때(unmount)” 한 번만 실행됩니다.
// - 대표적인 활용: 이벤트 등록, 구독, 타이머 설정, API 초기 요청 등 “1회성 초기 작업”.

// ---------------------------------------------------------------------------------
// ✅ 1. 기본 구조 예시
// ---------------------------------------------------------------------------------
useEffect(() => {
  // 실행할 코드
}, []);

// 위 구조는 "마운트 시 한 번만 실행"되는 패턴을 의미합니다.
// 빈 배열([])이기 때문에 이후 re-render 시에는 의존성 변화가 없어 effect가 재실행되지 않습니다.

// ---------------------------------------------------------------------------------
// ✅ 2. 기본 예제 — 컴포넌트가 처음 나타날 때 한 번만 실행
// ---------------------------------------------------------------------------------
import { useEffect } from "react";

function Welcome() {
  useEffect(() => {
    // 이 코드는 화면에 컴포넌트가 처음 그려진 직후 실행됩니다.
    console.log("컴포넌트가 처음 나타난 직후에만 실행됩니다.");
  }, []); // 빈 배열 → 마운트 시 1회만 실행

  // 의존성 배열을 비워둔 이유:
  // - React는 이 배열의 내부 값을 비교해서 재실행 여부를 결정합니다.
  // - 아무 값도 없으므로 ‘변화가 없음’으로 간주되어 재실행하지 않습니다.

  return <h1>안녕하세요, React!</h1>;
}

export default Welcome;

// ---------------------------------------------------------------------------------
// ✅ 3. Cleanup(정리) 코드 포함 예시
// ---------------------------------------------------------------------------------
useEffect(() => {
  console.log("처음 한 번 실행");

  // Cleanup 함수는 반환(return) 형태로 작성합니다.
  return () => {
    console.log("컴포넌트가 화면에서 사라질 때 정리");
  };
}, []);

// 실행 순서 요약:
// ① 컴포넌트 마운트 → Effect 실행 ("처음 한 번 실행")
// ② 이후 re-render는 발생해도 실행되지 않음
// ③ 언마운트 시 Cleanup 실행 ("컴포넌트가 화면에서 사라질 때 정리")

// ---------------------------------------------------------------------------------
// ✅ 4. 실제 활용 예시 — 모달 창에서 ESC 키로 닫기
// ---------------------------------------------------------------------------------
function Modal({ onClose }) {
  useEffect(() => {
    // (1) 마운트 시: 이벤트 등록
    const handleEsc = (e) => {
      // 사용자가 ESC 키를 누르면 모달 닫기 실행
      if (e.key === "Escape") {
        onClose();
      }
    };

    // 전역 window 객체에 keydown 이벤트 등록
    window.addEventListener("keydown", handleEsc);
    console.log("ESC 이벤트 등록됨");

    // (2) 언마운트 시: 이벤트 제거
    return () => {
      window.removeEventListener("keydown", handleEsc);
      console.log("ESC 이벤트 제거됨");
    };
  }, []); // 빈 배열 → 최초 마운트 시 1회 등록 / 언마운트 시 정리

  // 화면 구조
  return (
    <div className="modal">
      <h2>모달 창</h2>
      <p>ESC 키를 누르면 닫힙니다.</p>
    </div>
  );
}

// ---------------------------------------------------------------------------------
// ✅ 동작 원리 심화
// ---------------------------------------------------------------------------------
// React의 렌더링 사이클에서 useEffect([])는 다음 순서로 실행됩니다:
//
// 1️⃣ React가 컴포넌트를 렌더링한다 (가상 DOM 단계).
// 2️⃣ 렌더 결과가 실제 DOM에 반영된다 (commit 단계).
// 3️⃣ commit 이후에 Effect 콜백이 실행된다. (즉, 화면이 이미 그려진 뒤 실행)
// 4️⃣ Cleanup 함수는 다음 두 시점 중 하나에서 실행된다:
//     - 컴포넌트가 unmount될 때 (즉, 화면에서 사라질 때)
//     - 동일 Effect가 다시 실행되기 직전 (이 케이스에서는 해당 없음)
//
// 결과적으로 useEffect([])는 “마운트 시 실행 → 언마운트 시 정리”라는
// 가장 기본적이고 직관적인 생명주기 패턴을 구현합니다.
//
// 이 패턴은 전통적인 Class 컴포넌트의 componentDidMount / componentWillUnmount 역할을 대신합니다.
